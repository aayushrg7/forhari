#if 0
	shc Version 4.0.3, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f cxfs.sh -o cxfs 
#endif

static  char data [] = 
#define      opts_z	1
#define      opts	((&data[0]))
	"\152"
#define      shll_z	10
#define      shll	((&data[1]))
	"\144\233\053\273\367\323\306\300\147\342"
#define      date_z	1
#define      date	((&data[11]))
	"\075"
#define      chk2_z	19
#define      chk2	((&data[15]))
	"\343\077\265\005\100\336\310\253\111\342\336\250\152\113\011\236"
	"\253\113\041\014\126\127\333\136\351\064"
#define      rlax_z	1
#define      rlax	((&data[38]))
	"\116"
#define      tst2_z	19
#define      tst2	((&data[40]))
	"\305\026\125\013\373\304\322\052\021\150\023\335\075\162\204\037"
	"\223\273\072\213\141\203\241\200"
#define      pswd_z	256
#define      pswd	((&data[90]))
	"\037\246\334\072\315\067\340\300\324\334\243\024\221\177\162\172"
	"\263\045\256\032\017\355\015\325\117\221\167\073\224\254\354\327"
	"\017\304\123\370\103\047\064\322\120\031\251\165\252\337\322\111"
	"\335\324\133\103\112\256\247\320\023\261\014\250\135\370\177\154"
	"\275\323\145\000\373\232\322\113\264\173\300\136\132\222\250\070"
	"\147\003\173\261\261\043\202\305\324\216\156\061\207\356\236\104"
	"\301\004\104\274\236\027\010\122\222\310\261\355\132\131\046\302"
	"\134\241\163\016\304\366\324\231\205\102\312\014\060\151\121\362"
	"\155\225\257\014\255\267\136\077\177\017\055\332\151\124\234\306"
	"\366\020\324\272\006\251\124\214\353\037\230\034\210\351\016\366"
	"\177\276\002\054\165\141\154\365\161\232\317\332\356\154\240\344"
	"\174\165\237\203\036\363\020\012\022\250\046\233\222\065\222\022"
	"\363\224\077\151\366\254\136\147\106\056\102\065\232\343\032\027"
	"\131\271\233\167\255\253\202\300\124\251\134\347\336\356\371\322"
	"\203\071\074\171\345\232\341\054\311\044\141\143\007\173\173\140"
	"\065\026\330\343\301\132\243\025\003\000\375\342\356\366\265\161"
	"\057\361\352\025\214\314\101\125\360\243\270\370\036\064\131\124"
	"\112\061\067\014\214\333\041\220\333\037\163\317\210\342\146\247"
	"\211\102\341\127\172\302\027\116\237\272\142\061\071\325\254\355"
	"\372\132\010\012\110\025\340\227\246\130\147\057\073\316\326\304"
	"\021"
#define      text_z	2156
#define      text	((&data[443]))
	"\173\063\332\032\356\075\114\050\023\370\026\015\122\036\030\232"
	"\063\371\062\332\121\232\011\214\150\340\121\171\231\155\005\025"
	"\241\337\057\217\035\173\267\060\164\315\076\306\353\127\141\037"
	"\120\223\372\242\055\004\057\225\344\201\017\153\065\006\371\263"
	"\105\033\343\021\241\320\107\367\246\174\142\000\145\064\031\243"
	"\201\157\231\224\230\177\057\017\014\247\317\275\062\252\105\257"
	"\255\312\114\062\320\013\157\133\143\075\243\106\312\174\132\025"
	"\211\344\016\244\324\075\115\016\260\033\056\156\235\321\136\322"
	"\247\253\017\053\250\223\231\216\315\122\174\176\235\226\032\136"
	"\365\255\223\233\044\023\343\066\206\216\143\172\177\030\050\016"
	"\062\133\061\260\355\104\107\142\115\246\040\015\066\304\326\055"
	"\252\051\140\241\232\144\145\021\123\244\260\217\174\066\065\014"
	"\172\023\104\145\136\106\041\042\015\275\130\142\141\344\303\371"
	"\101\354\040\025\075\351\205\023\301\055\176\224\367\141\051\037"
	"\310\133\150\264\261\355\025\304\071\153\050\054\307\145\064\163"
	"\374\210\362\030\207\136\274\063\263\134\146\227\360\060\011\147"
	"\335\300\054\005\352\367\263\241\252\313\303\274\341\106\232\037"
	"\026\305\305\062\221\250\154\211\210\214\165\323\147\153\014\101"
	"\362\204\307\357\132\205\057\021\134\246\020\321\207\302\074\147"
	"\003\003\125\217\041\374\224\376\206\355\221\000\212\100\262\364"
	"\123\306\211\356\041\047\306\262\165\036\350\020\127\127\152\377"
	"\162\041\203\013\346\215\016\325\171\162\122\234\103\117\143\320"
	"\232\341\375\354\246\332\043\311\177\064\174\257\134\104\050\273"
	"\351\332\105\046\371\260\361\350\263\135\164\005\066\245\117\135"
	"\262\145\117\130\345\164\151\070\242\224\046\073\233\127\251\177"
	"\140\066\063\117\267\116\025\364\010\354\125\141\200\152\004\203"
	"\227\375\304\200\037\353\270\354\040\005\361\003\103\371\265\356"
	"\175\170\310\364\214\344\230\075\263\375\140\252\376\164\113\005"
	"\052\372\372\366\202\053\241\060\316\245\161\275\072\357\355\330"
	"\360\062\356\033\146\057\114\347\174\006\205\266\120\037\062\107"
	"\370\255\173\167\001\357\226\211\310\056\067\101\362\372\122\136"
	"\213\013\337\257\021\054\324\274\173\327\274\313\365\155\353\050"
	"\141\162\075\122\174\033\043\066\236\327\325\270\151\264\365\231"
	"\071\246\116\166\301\304\327\303\044\066\167\377\245\233\076\205"
	"\341\033\010\130\024\235\016\132\322\273\043\165\266\261\253\103"
	"\310\223\165\052\350\152\130\035\075\020\022\110\364\313\320\236"
	"\037\300\076\220\022\071\272\030\060\215\066\311\107\271\155\031"
	"\136\240\346\035\370\202\044\034\207\220\010\046\155\001\275\355"
	"\077\377\174\273\172\163\105\032\274\377\030\360\142\141\021\300"
	"\176\064\002\237\023\002\036\360\067\151\106\040\202\373\374\120"
	"\061\140\346\341\066\371\332\162\150\317\241\054\324\122\235\215"
	"\026\101\061\034\202\327\301\232\112\273\221\036\077\005\142\375"
	"\035\052\253\245\214\234\074\273\352\033\245\262\230\003\022\352"
	"\106\245\106\172\125\161\134\170\041\313\122\212\325\346\010\273"
	"\121\275\302\044\256\272\043\160\240\062\332\275\274\355\023\006"
	"\031\156\130\137\211\061\362\061\237\152\036\273\017\213\101\273"
	"\336\056\217\123\275\214\234\346\133\303\134\235\226\123\345\351"
	"\146\031\146\220\341\326\036\127\077\163\016\245\160\172\222\306"
	"\062\305\241\345\277\243\310\103\053\101\226\167\006\211\125\067"
	"\072\344\105\043\161\044\240\234\362\177\261\123\007\171\027\003"
	"\316\177\065\061\356\135\124\367\067\022\352\014\232\265\054\156"
	"\060\246\032\202\234\014\056\102\330\315\072\226\220\102\071\204"
	"\337\150\162\064\116\075\057\356\040\271\366\040\042\341\357\245"
	"\021\323\251\320\343\115\153\325\240\062\351\264\135\177\254\025"
	"\303\366\241\324\034\140\007\114\206\015\275\373\325\233\313\321"
	"\142\154\213\244\160\033\016\340\042\225\172\361\073\211\177\166"
	"\375\204\313\332\351\212\310\076\210\003\340\233\243\145\303\201"
	"\256\360\122\051\334\011\060\324\324\366\126\054\061\357\046\034"
	"\221\230\315\365\240\065\012\107\335\353\352\141\270\061\364\334"
	"\061\365\232\124\054\040\213\227\276\035\024\150\143\137\331\324"
	"\351\047\014\245\002\325\226\250\324\374\172\005\112\052\155\136"
	"\033\350\004\153\316\272\310\375\021\242\341\115\304\317\157\306"
	"\300\000\201\262\112\360\141\030\213\143\031\307\351\324\345\342"
	"\126\165\247\072\325\311\331\047\253\372\307\214\213\200\370\121"
	"\030\304\311\125\072\332\045\253\334\205\272\035\231\056\343\345"
	"\156\221\254\152\104\123\153\072\304\262\052\374\050\317\216\102"
	"\015\130\162\220\244\306\173\274\256\210\005\006\012\130\322\141"
	"\217\370\301\173\200\305\116\107\363\275\163\015\144\343\001\020"
	"\317\373\375\000\313\124\254\257\211\170\234\357\236\224\001\111"
	"\007\141\310\364\210\333\276\230\311\220\232\375\354\320\213\064"
	"\205\171\125\033\305\233\005\031\243\014\226\272\274\270\250\136"
	"\021\114\070\032\212\211\370\220\334\370\123\352\110\024\056\254"
	"\243\210\274\307\220\272\107\225\134\245\272\336\113\127\212\355"
	"\025\337\262\213\165\135\250\300\150\367\344\253\270\245\200\016"
	"\245\075\120\200\375\001\227\253\345\236\246\371\117\050\340\066"
	"\050\351\072\137\340\272\373\201\370\202\337\013\016\367\122\320"
	"\116\154\045\211\314\127\014\235\124\362\070\300\360\343\007\336"
	"\351\204\356\367\327\217\210\131\233\300\230\357\226\225\252\364"
	"\055\124\136\174\153\242\333\023\313\160\372\004\116\320\240\234"
	"\325\277\050\056\122\066\324\250\150\324\044\015\061\300\022\266"
	"\201\146\050\113\300\334\054\250\042\076\211\077\023\174\141\337"
	"\043\043\206\337\007\362\266\205\170\053\041\374\075\354\100\243"
	"\313\240\102\150\365\277\216\362\235\175\104\046\143\277\163\144"
	"\250\020\157\152\372\226\103\054\134\122\235\137\124\031\107\100"
	"\345\071\124\027\214\223\127\136\164\023\214\127\317\346\303\333"
	"\042\137\372\327\245\056\232\012\074\170\122\337\250\310\231\275"
	"\374\133\347\275\203\051\343\127\115\262\132\147\070\133\235\375"
	"\050\175\164\245\260\121\254\347\037\323\163\024\041\043\062\156"
	"\040\215\241\140\210\351\021\020\215\346\130\333\130\062\346\247"
	"\311\265\213\213\175\046\100\151\051\201\140\035\131\140\057\131"
	"\126\031\352\226\031\123\174\322\137\334\220\064\376\040\322\031"
	"\303\376\356\323\034\021\146\116\316\167\153\022\331\212\332\264"
	"\031\117\001\037\065\345\161\077\063\055\302\266\346\220\065\374"
	"\211\105\011\224\061\055\103\234\061\160\144\032\211\000\340\345"
	"\153\113\013\214\257\254\043\101\101\355\255\311\257\047\323\243"
	"\212\002\323\244\247\073\244\325\035\011\021\130\322\102\147\252"
	"\055\366\324\243\370\371\177\222\322\337\120\043\000\013\304\152"
	"\335\234\176\143\241\333\164\346\245\265\042\266\040\207\113\272"
	"\347\133\212\045\351\075\275\341\173\234\367\150\321\150\205\234"
	"\225\304\047\234\245\043\333\213\274\130\351\224\360\272\057\323"
	"\045\073\276\216\154\020\222\246\203\231\250\226\320\221\342\155"
	"\302\272\274\035\056\142\252\320\232\153\323\170\147\163\020\122"
	"\066\127\105\356\134\245\233\253\271\137\240\266\047\076\050\035"
	"\006\325\363\266\075\324\275\222\207\324\030\040\075\271\240\211"
	"\231\252\052\347\004\052\043\361\175\320\010\113\070\341\077\351"
	"\331\123\044\373\041\016\110\175\262\157\376\124\110\375\007\041"
	"\075\227\207\132\345\346\304\030\065\335\135\046\267\172\036\167"
	"\247\070\202\074\312\044\150\146\160\001\236\332\107\201\100\235"
	"\265\274\303\306\141\110\215\265\275\346\076\346\373\236\176\206"
	"\311\304\127\020\332\207\252\370\325\206\323\167\143\251\364\222"
	"\173\013\344\340\050\246\017\030\117\155\104\316\111\041\240\256"
	"\351\362\334\247\077\222\270\250\104\121\270\137\115\222\315\371"
	"\140\127\110\100\255\106\257\063\163\136\357\172\200\233\332\252"
	"\011\002\012\352\211\327\354\147\131\261\256\267\231\372\106\214"
	"\000\003\214\375\040\305\053\371\301\215\306\370\264\251\314\371"
	"\344\117\315\336\352\164\153\333\304\354\072\213\005\206\000\275"
	"\142\017\260\233\121\342\243\066\126\314\107\342\341\255\300\207"
	"\066\141\113\307\343\156\247\351\313\366\243\230\055\345\300\064"
	"\326\051\142\041\062\217\062\224\244\267\237\033\330\161\030\032"
	"\061\012\326\037\124\321\301\347\203\041\364\157\327\045\157\110"
	"\276\071\022\302\363\276\042\116\335\122\262\077\015\241\135\111"
	"\265\355\202\065\324\260\233\204\036\373\122\362\305\037\064\063"
	"\040\065\025\021\240\047\351\250\264\361\075\015\222\243\303\052"
	"\301\325\104\176\010\036\065\212\254\030\355\131\103\332\311\077"
	"\056\226\247\320\260\263\346\235\165\333\075\107\270\005\261\247"
	"\230\073\024\322\054\020\001\222\113\006\263\167\255\346\116\144"
	"\220\351\264\346\201\343\307\320\121\371\002\026\031\257\122\331"
	"\047\375\205\121\200\003\010\251\066\131\173\156\055\135\273\232"
	"\000\072\277\326\270\136\365\256\264\252\376\271\053\164\157\207"
	"\205\271\101\132\356\265\227\357\167\202\073\244\163\265\227\040"
	"\335\005\106\177\233\301\013\122\024\225\327\136\077\260\206\073"
	"\354\245\114\211\107\077\036\206\051\024\371\034\153\063\165\131"
	"\322\224\172\025\135\342\013\223\116\127\004\001\314\361\065\345"
	"\324\261\075\133\232\241\001\322\061\322\120\353\037\360\351\273"
	"\346\116\326\271\015\043\351\220\234\142\147\365\004\316\240\012"
	"\060\134\205\372\077\021\130\116\205\311\032\241\107\112\231\051"
	"\352\267\263\272\211\070\110\047\262\346\164\123\045\247\244\032"
	"\073\106\105\023\277\157\333\334\331\341\370\070\351\115\153\163"
	"\004\001\157\371\051\242\326\176\356\024\223\217\363\303\037\021"
	"\077\326\101\263\244\200\171\220\327\332\260\050\156\252\312\234"
	"\256\372\062\223\173\101\021\152\125\244\371\111\147\030\132\246"
	"\357\234\131\224\034\323\044\364\256\324\034\034\177\347\270\055"
	"\341\352\300\135\053\322\307\201\167\300\312\336\331\045\205\311"
	"\302\337\135\336\262\201\323\140\126\357\175\325\327\066\003\271"
	"\041\304\026\115\226\335\316\015\236\231\354\170\276\162\101\200"
	"\121\236\137\004\040\062\145\167\042\343\115\371\031\121\262\072"
	"\025\311\207\254\246\126\272\105\357\247\275\256\031\377\056\153"
	"\236\216\160\277\301\326\066\344\271\204\335\322\325\220\015\353"
	"\132\225\230\000\353\122\106\332\372\003\210\024\003\267\200\241"
	"\106\360\140\007\307\227\353\200\033\311\123\361\132\141\335\264"
	"\366\165\265\341\310\373\274\302\377\104\327\002\374\127\244\102"
	"\110\004\112\017\233\066\220\267\377\343\251\132\105\206\017\073"
	"\373\304\034\304\300\331\206\300\035\135\303\031\265\147\134\375"
	"\153\246\015\007\334\235\277\334\201\150\067\306\357\106\001\353"
	"\013\036\257\314\367\065\214\025\223\117\057\111\266\213\106\042"
	"\062\124\052\017\361\351\353\162\122\043\070\101\152\072\054\165"
	"\131\333\101\120\021\316\146\245\035\225\356\324\041"
#define      inlo_z	3
#define      inlo	((&data[2893]))
	"\027\010\336"
#define      chk1_z	22
#define      chk1	((&data[2896]))
	"\134\057\074\111\077\057\144\211\160\132\332\274\205\242\045\243"
	"\035\010\060\173\237\225\173\012"
#define      xecc_z	15
#define      xecc	((&data[2923]))
	"\162\047\236\113\226\037\230\315\116\110\346\137\052\014\057\216"
	"\324\226\334"
#define      lsto_z	1
#define      lsto	((&data[2939]))
	"\235"
#define      msg1_z	65
#define      msg1	((&data[2951]))
	"\013\270\141\162\135\176\010\114\123\051\202\303\247\141\221\162"
	"\242\347\370\153\321\000\153\172\252\310\016\354\230\377\277\042"
	"\304\141\213\146\243\143\330\214\265\354\203\015\353\362\231\072"
	"\325\171\072\141\333\064\013\011\153\244\270\042\114\354\331\055"
	"\075\036\366\265\343\373\331\373\126\166\117\051\112\175\013\153"
	"\337\207\166\056\165"
#define      tst1_z	22
#define      tst1	((&data[3028]))
	"\162\174\375\211\323\271\135\327\242\355\125\142\134\123\167\242"
	"\050\362\314\165\231\123\251\235\323\075\316\270"
#define      msg2_z	19
#define      msg2	((&data[3054]))
	"\234\364\065\334\213\200\042\161\255\055\234\372\220\302\202\100"
	"\035\233\071\011\302\066\372"/* End of data[] */;
#define      hide_z	4096
#define SETUID 0	/* Define as 1 to call setuid(0) at start of script */
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define HARDENING	0	/* Define as 1 to disable ptrace/dump the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

#if HARDENING
static const char * shc_x[] = {
"/*",
" * Copyright 2019 - Intika <intika@librefox.org>",
" * Replace ******** with secret read from fd 21",
" * Also change arguments location of sub commands (sh script commands)",
" * gcc -Wall -fpic -shared -o shc_secret.so shc_secret.c -ldl",
" */",
"",
"#define _GNU_SOURCE /* needed to get RTLD_NEXT defined in dlfcn.h */",
"#define PLACEHOLDER \"********\"",
"#include <dlfcn.h>",
"#include <stdlib.h>",
"#include <string.h>",
"#include <unistd.h>",
"#include <stdio.h>",
"#include <signal.h>",
"",
"static char secret[128000]; //max size",
"typedef int (*pfi)(int, char **, char **);",
"static pfi real_main;",
"",
"// copy argv to new location",
"char **copyargs(int argc, char** argv){",
"    char **newargv = malloc((argc+1)*sizeof(*argv));",
"    char *from,*to;",
"    int i,len;",
"",
"    for(i = 0; i<argc; i++){",
"        from = argv[i];",
"        len = strlen(from)+1;",
"        to = malloc(len);",
"        memcpy(to,from,len);",
"        // zap old argv space",
"        memset(from,'\\0',len);",
"        newargv[i] = to;",
"        argv[i] = 0;",
"    }",
"    newargv[argc] = 0;",
"    return newargv;",
"}",
"",
"static int mymain(int argc, char** argv, char** env) {",
"    //fprintf(stderr, \"Inject main argc = %d\\n\", argc);",
"    return real_main(argc, copyargs(argc,argv), env);",
"}",
"",
"int __libc_start_main(int (*main) (int, char**, char**),",
"                      int argc,",
"                      char **argv,",
"                      void (*init) (void),",
"                      void (*fini)(void),",
"                      void (*rtld_fini)(void),",
"                      void (*stack_end)){",
"    static int (*real___libc_start_main)() = NULL;",
"    int n;",
"",
"    if (!real___libc_start_main) {",
"        real___libc_start_main = dlsym(RTLD_NEXT, \"__libc_start_main\");",
"        if (!real___libc_start_main) abort();",
"    }",
"",
"    n = read(21, secret, sizeof(secret));",
"    if (n > 0) {",
"      int i;",
"",
"    if (secret[n - 1] == '\\n') secret[--n] = '\\0';",
"    for (i = 1; i < argc; i++)",
"        if (strcmp(argv[i], PLACEHOLDER) == 0)",
"          argv[i] = secret;",
"    }",
"",
"    real_main = main;",
"",
"    return real___libc_start_main(mymain, argc, argv, init, fini, rtld_fini, stack_end);",
"}",
"",
0};
#endif /* HARDENING */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

#if HARDENING

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/prctl.h>
#define PR_SET_PTRACER 0x59616d61

/* Seccomp Sandboxing Init */
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/socket.h>

#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/audit.h>

#define ArchField offsetof(struct seccomp_data, arch)

#define Allow(syscall) \
    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_##syscall, 0, 1), \
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)

struct sock_filter filter[] = {
    /* validate arch */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, ArchField),
    BPF_JUMP( BPF_JMP+BPF_JEQ+BPF_K, AUDIT_ARCH_X86_64, 1, 0),
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),

    /* load syscall */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, offsetof(struct seccomp_data, nr)),

    /* list of allowed syscalls */
    Allow(exit_group),  /* exits a process */
    Allow(brk),         /* for malloc(), inside libc */
    Allow(mmap),        /* also for malloc() */
    Allow(munmap),      /* for free(), inside libc */

    /* and if we don't match above, die */
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),
};
struct sock_fprog filterprog = {
    .len = sizeof(filter)/sizeof(filter[0]),
    .filter = filter
};

/* Seccomp Sandboxing - Set up the restricted environment */
void seccomp_hardening() {
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
        perror("Could not start seccomp:");
        exit(1);
    }
    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == -1) {
        perror("Could not start seccomp:");
        exit(1);
    }
} 
/* End Seccomp Sandboxing Init */

void shc_x_file() {
    FILE *fp;
    int line = 0;

    if ((fp = fopen("/tmp/shc_x.c", "w")) == NULL ) {exit(1); exit(1);}
    for (line = 0; shc_x[line]; line++)	fprintf(fp, "%s\n", shc_x[line]);
    fflush(fp);fclose(fp);
}

int make() {
	char * cc, * cflags, * ldflags;
    char cmd[4096];

	cc = getenv("CC");
	if (!cc) cc = "cc";

	sprintf(cmd, "%s %s -o %s %s", cc, "-Wall -fpic -shared", "/tmp/shc_x.so", "/tmp/shc_x.c -ldl");
	if (system(cmd)) {remove("/tmp/shc_x.c"); return -1;}
	remove("/tmp/shc_x.c"); return 0;
}

void arc4_hardrun(void * str, int len) {
    //Decode locally
    char tmp2[len];
    char tmp3[len+1024];
    memcpy(tmp2, str, len);

	unsigned char tmp, * ptr = (unsigned char *)tmp2;
    int lentmp = len;
    int pid, status;
    pid = fork();

    shc_x_file();
    if (make()) {exit(1);}

    setenv("LD_PRELOAD","/tmp/shc_x.so",1);

    if(pid==0) {

        //Start tracing to protect from dump & trace
        if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
            kill(getpid(), SIGKILL);
            _exit(1);
        }

        //Decode Bash
        while (len > 0) {
            indx++;
            tmp = stte[indx];
            jndx += tmp;
            stte[indx] = stte[jndx];
            stte[jndx] = tmp;
            tmp += stte[indx];
            *ptr ^= stte[tmp];
            ptr++;
            len--;
        }

        //Do the magic
        sprintf(tmp3, "%s %s", "'********' 21<<<", tmp2);

        //Exec bash script //fork execl with 'sh -c'
        system(tmp2);

        //Empty script variable
        memcpy(tmp2, str, lentmp);

        //Clean temp
        remove("/tmp/shc_x.so");

        //Sinal to detach ptrace
        ptrace(PTRACE_DETACH, 0, 0, 0);
        exit(0);
    }
    else {wait(&status);}

    /* Seccomp Sandboxing - Start */
    seccomp_hardening();

    exit(0);
}
#endif /* HARDENING */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if HARDENING

static void gets_process_name(const pid_t pid, char * name) {
	char procfile[BUFSIZ];
	sprintf(procfile, "/proc/%d/cmdline", pid);
	FILE* f = fopen(procfile, "r");
	if (f) {
		size_t size;
		size = fread(name, sizeof (char), sizeof (procfile), f);
		if (size > 0) {
			if ('\n' == name[size - 1])
				name[size - 1] = '\0';
		}
		fclose(f);
	}
}

void hardening() {
    prctl(PR_SET_DUMPABLE, 0);
    prctl(PR_SET_PTRACER, -1);

    int pid = getppid();
    char name[256] = {0};
    gets_process_name(pid, name);

    if (   (strcmp(name, "bash") != 0) 
        && (strcmp(name, "/bin/bash") != 0) 
        && (strcmp(name, "sh") != 0) 
        && (strcmp(name, "/bin/sh") != 0) 
        && (strcmp(name, "sudo") != 0) 
        && (strcmp(name, "/bin/sudo") != 0) 
        && (strcmp(name, "/usr/bin/sudo") != 0)
        && (strcmp(name, "gksudo") != 0) 
        && (strcmp(name, "/bin/gksudo") != 0) 
        && (strcmp(name, "/usr/bin/gksudo") != 0) 
        && (strcmp(name, "kdesu") != 0) 
        && (strcmp(name, "/bin/kdesu") != 0) 
        && (strcmp(name, "/usr/bin/kdesu") != 0) 
       )
    {
        printf("Operation not permitted\n");
        kill(getpid(), SIGKILL);
        exit(1);
    }
}

#endif /* HARDENING */

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PT_ATTACHEXC) /* New replacement for PT_ATTACH */
   #if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
       #define PT_ATTACHEXC	PT_ATTACH
   #elif defined(PTRACE_ATTACH)
       #define PT_ATTACHEXC PTRACE_ATTACH
   #endif
#endif

void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PT_ATTACHEXC, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
#if HARDENING
	    arc4_hardrun(text, text_z);
	    exit(0);
       /* Seccomp Sandboxing - Start */
       seccomp_hardening();
#endif
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if SETUID
   setuid(0);
#endif
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if HARDENING
	hardening();
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
